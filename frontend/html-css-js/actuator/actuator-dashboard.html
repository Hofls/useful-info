<!--
Replace "someit.com" URLS with real ones
If you try to run it locally and get CORS error, gotta install "CORS Unblock" chrome extension
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Actuator Metrics Dashboard</title>
    <style>
        :root {
            --bg: #fafafa;
            --surface: #ffffff;
            --border: #e0e0e0;
            --text: #333333;
            --text-light: #757575;
            --accent: #000000;
            --accent-light: #f0f0f0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 40px;
            background-color: var(--bg);
            color: var(--text);
            font-size: 14px;
            line-height: 1.6;
            font-weight: 400;
        }

        h1 {
            font-weight: 500;
            font-size: 24px;
            margin: 0 0 40px 0;
            color: var(--accent);
            letter-spacing: -0.5px;
        }

        /* Tab Container */
        .tab-container {
            display: flex;
            border-bottom: 1px solid var(--border);
            margin-bottom: 30px;
            gap: 4px;
        }

        .tab-button {
            padding: 12px 24px;
            cursor: pointer;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            font-size: 14px;
            color: var(--text-light);
            font-weight: 400;
            transition: all 0.15s ease;
            margin-bottom: -1px;
        }

        .tab-button:hover {
            color: var(--text);
        }

        .tab-button.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
            font-weight: 500;
        }

        /* Tab Content */
        .tab-content {
            display: none;
            max-width: 1200px;
        }

        .tab-content.active {
            display: block;
        }

        /* Input and Buttons */
        input[type="text"] {
            width: 97%;
            padding: 12px 16px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
            background: var(--surface);
            font-size: 14px;
            color: var(--text);
            border-radius: 0;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
        }

        button:hover {
            background: var(--accent-light);
            border-color: var(--accent);
        }

        /* Section Styling */
        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            font-weight: 500;
            font-size: 16px;
            margin: 0 0 20px 0;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Table Styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
        }

        th {
            text-align: left;
            padding: 12px 16px;
            font-weight: 500;
            color: var(--text);
            border-bottom: 1px solid var(--border);
            background: #a0beff;
        }

        td {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            color: var(--text);
        }

        tr:last-child td {
            border-bottom: none;
        }

        /* Pre/code styling */
        pre {
            background: var(--surface);
            border: 1px solid var(--border);
            padding: 20px;
            margin: 0;
            font-family: 'SF Mono', Menlo, Monaco, Consolas, monospace;
            font-size: 13px;
            color: var(--text);
            overflow-x: auto;
            white-space: pre-wrap;
        }

        /* Utility */
        @media (max-width: 768px) {
            body {
                padding: 20px;
            }

            .tab-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .tab-button {
                white-space: nowrap;
            }
        }
    </style>
</head>
<body>
    <h1>Actuator Metrics Dashboard</h1>

    <div class="tab-container">
        <button class="tab-button active" onclick="openTab(event, 'ms-actor')">ms-actor</button>
        <button class="tab-button" onclick="openTab(event, 'ms-warehouse')">ms-warehouse</button>
        <button class="tab-button" onclick="openTab(event, 'ms-external')">ms-external</button>
        <button class="tab-button" onclick="openTab(event, 'ms-equipment')">ms-equipment</button>
        <button class="tab-button" onclick="openTab(event, 'ms-user')">ms-user</button>
    </div>

    <!-- ms-actor Tab -->
    <div id="ms-actor" class="tab-content active">
        <input type="text" id="url-ms-actor" placeholder="Enter Actuator URL for ms-actor" value="http://someit.com/ms-actor">
        <div id="prometheus-output-ms-actor" class="section"></div>
        <div id="slow-endpoints-output-ms-actor" class="section"></div>
        <div id="endpoint-errors-output-ms-actor" class="section"></div>
    </div>

    <!-- ms-warehouse Tab -->
    <div id="ms-warehouse" class="tab-content">
        <input type="text" id="url-ms-warehouse" placeholder="Enter Actuator URL for ms-warehouse" value="http://someit.com/ms-warehouse">
        <div id="prometheus-output-ms-warehouse" class="section"></div>
        <div id="slow-endpoints-output-ms-warehouse" class="section"></div>
        <div id="endpoint-errors-output-ms-warehouse" class="section"></div>
    </div>

    <!-- ms-external Tab -->
    <div id="ms-external" class="tab-content">
        <input type="text" id="url-ms-external" placeholder="Enter Actuator URL for ms-external" value="http://someit.com/ms-external">
        <div id="prometheus-output-ms-external" class="section"></div>
        <div id="slow-endpoints-output-ms-external" class="section"></div>
        <div id="endpoint-errors-output-ms-external" class="section"></div>
    </div>

    <!-- ms-equipment Tab -->
    <div id="ms-equipment" class="tab-content">
        <input type="text" id="url-ms-equipment" placeholder="Enter Actuator URL for ms-equipment" value="http://someit.com/ms-equipment">
        <div id="prometheus-output-ms-equipment" class="section"></div>
        <div id="slow-endpoints-output-ms-equipment" class="section"></div>
        <div id="endpoint-errors-output-ms-equipment" class="section"></div>
    </div>

    <!-- ms-user Tab -->
    <div id="ms-user" class="tab-content">
        <input type="text" id="url-ms-user" placeholder="Enter Actuator URL for ms-user" value="http://someit.com/ms-user">
        <div id="prometheus-output-ms-user" class="section"></div>
        <div id="slow-endpoints-output-ms-user" class="section"></div>
        <div id="endpoint-errors-output-ms-user" class="section"></div>
    </div>

    <script>
        // Track which tabs have been initialized
        const initializedTabs = new Set([]);

        // Add initialization for the first tab since it's active by default
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (!initializedTabs.has('ms-actor')) {
                    runAllScriptsForProject('ms-actor');
                    initializedTabs.add('ms-actor');
                }
            }, 100); // Small delay to ensure DOM is ready
        });

        // Tab functionality
        function openTab(evt, tabName) {
            var i, tabcontent, tabbuttons;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tabbuttons = document.getElementsByClassName("tab-button");
            for (i = 0; i < tabbuttons.length; i++) {
                tabbuttons[i].className = tabbuttons[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";

            // Run scripts for the tab if it hasn't been initialized yet
            if (!initializedTabs.has(tabName)) {
                runAllScriptsForProject(tabName);
                initializedTabs.add(tabName);
            }
        }

        // --- Prometheus Script Logic ---
        async function runPrometheusScript(projectId) {
            const urlInput = document.getElementById(`url-${projectId}`);
            const url = urlInput.value.trim();
            if (!url) {
                alert(`Please enter a URL for ${projectId}`);
                return;
            }

            try {
                const fullUrl = url.endsWith('/actuator/prometheus') ? url : `${url}/actuator/prometheus`;
                const response = await fetch(fullUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const text = await response.text();
                const data = parsePrometheusMetrics(text);
                printHealthSummaryHTML(data, projectId);
            } catch (err) {
                const outputDiv = document.getElementById(`prometheus-output-${projectId}`);
                outputDiv.innerHTML = `<pre>Failed to fetch or parse metrics: ${err.message}</pre>`;
            }
        }

        function parsePrometheusMetrics(text) {
            const lines = text.split('\n');
            const data = {};
            for (const line of lines) {
                if (!line || line.startsWith('#')) continue;
                const lastSpaceIndex = line.lastIndexOf(' ');
                const keyPart = line.slice(0, lastSpaceIndex).trim();
                const value = Number(line.slice(lastSpaceIndex + 1));
                const num = parseFloat(value);
                if (!keyPart || isNaN(num)) continue;

                const m = keyPart.match(/^([^{]+)(?:{(.*)})?$/);
                if (!m) continue;

                const metric = m[1];
                const labelsStr = m[2] || '';

                if (!labelsStr) {
                    data[metric] = num;
                    continue;
                }

                const name = labelsStr.match(/name="([^"]+)"/)?.[1];
                const state = labelsStr.match(/state="([^"]+)"/)?.[1];
                const id = labelsStr.match(/id="([^"]+)"/)?.[1];
                const level = labelsStr.match(/level="([^"]+)"/)?.[1];

                if (name) {
                    data[`${metric}_${name}`] = num;
                } else if (state) {
                    data[`${metric}_${state}`] = num;
                } else if (id) {
                    const safeId = id.replace(/[^a-zA-Z0-9_]/g, '_');
                    data[`${metric}_${safeId.toLowerCase()}`] = num;
                } else if (level) {
                    data[`${metric}_${level}`] = num;
                } else {
                    data[`${metric}`] = num;
                }
            }
            return data;
        }

        function printHealthSummaryHTML(data, projectId) {
            let html = `
            <div class="section">
                <h2>Spring Boot Quick Health (${projectId})</h2>
                <table>
                    <tr><th>CPU</th><th></th></tr>
            `;

            const cpu = data['process_cpu_usage'] ?? data['system_cpu_usage'];
            html += `<tr><td>CPU usage</td><td>${(cpu * 100).toFixed(1)}%</td></tr>`;

            html += `
                    <tr><th>JVM Memory — USED</th><th></th></tr>
                    <tr><td>Heap Tenured used<br><small>(old generation – long-lived objects)</small></td><td>${(data['jvm_memory_used_bytes_tenured_gen'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap Eden used<br><small>(young generation – where new objects are allocated)</small></td><td>${(data['jvm_memory_used_bytes_eden_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap Survivor used<br><small>(young gen – objects that survived GC cycles)</small></td><td>${(data['jvm_memory_used_bytes_survivor_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>MetaSpace used<br><small>(class metadata, method bytecode, interned strings...)</small></td><td>${(data['jvm_memory_used_bytes_metaspace'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Compressed Class Space used<br><small>(compressed pointers – class metadata subset, 32-bit JVMs)</small></td><td>${(data['jvm_memory_used_bytes_compressed_class_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>

                    <tr><th>JVM Memory — COMMITTED</th><th></th></tr>
                    <tr><td>Heap Tenured committed<br><small>(old gen memory OS has reserved for this area)</small></td><td>${(data['jvm_memory_committed_bytes_tenured_gen'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap Eden committed<br><small>(young gen Eden – reserved by OS)</small></td><td>${(data['jvm_memory_committed_bytes_eden_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap Survivor committed<br><small>(young gen survivor spaces – reserved)</small></td><td>${(data['jvm_memory_committed_bytes_survivor_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>MetaSpace committed<br><small>(committed memory for class metadata)</small></td><td>${(data['jvm_memory_committed_bytes_metaspace'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Compressed Class Space committed<br><small>(committed portion of compressed class area)</small></td><td>${(data['jvm_memory_committed_bytes_compressed_class_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>

                    <tr><th>JVM Memory — MAX</th><th></th></tr>
                    <tr><td>Heap Tenured max<br><small>(maximum size old generation can grow to)</small></td><td>${(data['jvm_memory_max_bytes_tenured_gen'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap Eden max<br><small>(max size of Eden – usually -Xmn / young gen config)</small></td><td>${(data['jvm_memory_max_bytes_eden_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap Survivor max<br><small>(max size of each survivor space)</small></td><td>${(data['jvm_memory_max_bytes_survivor_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>MetaSpace max<br><small>(-XX:MaxMetaspaceSize limit, often unlimited)</small></td><td>${(data['jvm_memory_max_bytes_metaspace'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Compressed Class Space max<br><small>(usually fixed ~1 GB on 64-bit JVMs)</small></td><td>${(data['jvm_memory_max_bytes_compressed_class_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>

                    <tr><th>Memory</th><th></th></tr>
                    <tr><td>Live heap post-GC<br><small>(old generation size after last major GC)</small></td><td>${(data['jvm_gc_live_data_size_bytes'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap used after GC<br><small>(% of max heap used right after GC)</small></td><td>${(data['jvm_memory_usage_after_gc_percent'] * 100).toFixed(1)}%</td></tr>
                    <tr><td>Promoted to old-gen<br><small>(total bytes promoted from young→old since start)</small></td><td>${(data['jvm_gc_memory_promoted_bytes_total'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Classes loaded<br><small>(current number of loaded classes)</small></td><td>${data['jvm_classes_loaded_classes']}</td></tr>

                    <tr><th>Threads</th><th></th></tr>
                    <tr><td>Peak threads<br><small>(highest number of live threads ever)</small></td><td>${data['jvm_threads_peak_threads'] | 0}</td></tr>
                    <tr><td>Runnable threads<br><small>(threads ready to run or running)</small></td><td>${data['jvm_threads_states_threads_runnable'] | 0}</td></tr>
                    <tr><td>Waiting threads<br><small>(threads in WAITING state – Object.wait())</small></td><td>${data['jvm_threads_states_threads_waiting'] | 0}</td></tr>
                    <tr><td>Timed waiting threads<br><small>(threads in TIMED_WAITING – sleep, wait(timeout), parkNanos...)</small></td><td>${data['jvm_threads_states_threads_timed'] | 0}</td></tr>
                    <tr><td>Blocked threads<br><small>(threads waiting for monitor – synchronized block)</small></td><td>${data['jvm_threads_states_threads_blocked'] | 0}</td></tr>
                    <tr><td>Daemon threads<br><small>(background threads – don't prevent JVM exit)</small></td><td>${data['jvm_threads_daemon_threads'] | 0}</td></tr>

                    <tr><th>Other</th><th></th></tr>
                    <tr><td>Uptime<br><small>(how long the JVM process has been running)</small></td><td>${Math.floor((Date.now()/1000 - data['process_start_time_seconds']) / 60)} min</td></tr>
                    <tr><td>Open files<br><small>(number of open file descriptors)</small></td><td>${data['process_files_open_files']}</td></tr>
                    <tr><td>Startup time<br><small>(time from process start to Spring Boot started event)</small></td><td>${data['application_started_time_seconds']} s</td></tr>
                    <tr><td>Ready time<br><small>(time from start to application fully ready – readiness probe)</small></td><td>${data['application_ready_time_seconds']} s</td></tr>
                    <tr><td>Errors logged<br><small>(total ERROR level log events via Logback)</small></td><td>${data['logback_events_total_error']}</td></tr>
                    <tr><td>Disk free<br><small>(free space on the filesystem where JVM runs)</small></td><td>${(data['disk_free_bytes'] / 1024 / 1024 / 1024).toFixed(1)} GB</td></tr>
                    <tr><td>JDBC connections min–max<br><small>(configured min/max pool size)</small></td><td>${data['jdbc_connections_min_dataSource'] | 0}–${data['jdbc_connections_max_dataSource'] | 0}</td></tr>

                    <tr><th>Executor</th><th></th></tr>
                    <tr><td>Tasks queued<br><small>(currently waiting in the task queue)</small></td><td>${data['executor_queued_tasks_threadPoolTaskScheduler']}</td></tr>
                    <tr><td>Tasks completed<br><small>(total tasks finished since start)</small></td><td>${data['executor_completed_tasks_total_threadPoolTaskScheduler']}</td></tr>
                    <tr><td>Executor threads<br><small>(current number of threads in pool)</small></td><td>${data['executor_pool_size_threads_threadPoolTaskScheduler']}</td></tr>

                    <tr><th>Database</th><th></th></tr>
                    <tr><td>DB connections active<br><small>(currently in use by application)</small></td><td>${data['hikaricp_connections_active']}</td></tr>
                    <tr><td>DB pool size<br><small>(total connections in Hikari pool right now)</small></td><td>${data['hikaricp_connections']}</td></tr>
                    <tr><td>DB max usage<br><small>(longest time any connection was borrowed)</small></td><td>${(data['hikaricp_connections_usage_seconds_max'] * 1000).toFixed(1)} ms</td></tr>
                    <tr><td>DB connections pending<br><small>(threads waiting for a connection)</small></td><td>${data['hikaricp_connections_pending']}</td></tr>
                    <tr><td>DB connections acquire max<br><small>(worst-case time to get connection from pool)</small></td><td>${data['hikaricp_connections_acquire_seconds_max']} s</td></tr>
                    <tr><td>DB connections timeout<br><small>(total times getConnection() timed out)</small></td><td>${data['hikaricp_connections_timeout_total']}</td></tr>
                </table>
            `;

            document.getElementById(`prometheus-output-${projectId}`).innerHTML = html;
        }


        // --- Slow Endpoints Script Logic ---
        async function runSlowEndpointsScript(projectId) {
            const urlInput = document.getElementById(`url-${projectId}`);
            const baseUrl = urlInput.value.trim();
            if (!baseUrl) {
                alert(`Please enter a URL for ${projectId}`);
                return;
            }

            try {
                const metricsBaseUrl = baseUrl.endsWith('/actuator/metrics/http.server.requests') ? baseUrl : `${baseUrl}/actuator/metrics/http.server.requests`;
                const endpointData = [];

                async function getAverageTime(endpointUrl) {
                    try {
                        const response = await fetch(endpointUrl);
                        const data = await response.json();
                        const totalTime = data.measurements.find((metric) => metric.statistic === 'TOTAL_TIME').value;
                        const count = data.measurements.find((metric) => metric.statistic === 'COUNT').value;
                        const averageTime = totalTime / count;
                        endpointData.push({ endpointUrl, averageTime });
                    } catch (e) {
                        // Silently ignore errors as per original script
                    }
                }

                async function getEndpointPaths() {
                    const response = await fetch(metricsBaseUrl);
                    const data = await response.json();
                    return data.availableTags.find(tag => tag.tag === 'uri').values;
                }

                const endpointPaths = await getEndpointPaths();
                for (const endpointPath of endpointPaths) {
                    const encodedPath = encodeURI(endpointPath);
                    const endpointMetricsUrl = `${metricsBaseUrl}?tag=uri:${encodedPath}`;
                    await getAverageTime(endpointMetricsUrl);
                }

                printSlowEndpointsHTML(endpointData, projectId);

            } catch (err) {
                const outputDiv = document.getElementById(`slow-endpoints-output-${projectId}`);
                outputDiv.innerHTML = `<pre>Failed to fetch slow endpoints: ${err.message}</pre>`;
            }
        }

        function printSlowEndpointsHTML(endpointData, projectId) {
            endpointData.sort((a, b) => b.averageTime - a.averageTime);
            const top20 = endpointData.slice(0, 20);

            let html = `
            <div class="section">
                <h2>TOP 20 SLOWEST ENDPOINTS (${projectId})</h2>
                <table>
                    <thead>
                        <tr><th>Average Time (seconds)</th><th>Endpoint</th></tr>
                    </thead>
                    <tbody>
            `;
            top20.forEach(item => {
                html += `<tr><td>${item.averageTime.toFixed(2)}</td><td>${item.endpointUrl}</td></tr>`;
            });
            html += `
                    </tbody>
                </table>
            </div>
            `;

            document.getElementById(`slow-endpoints-output-${projectId}`).innerHTML = html;
        }


        // --- Endpoint Errors Script Logic ---
        async function runEndpointErrorsScript(projectId) {
            const urlInput = document.getElementById(`url-${projectId}`);
            const baseUrl = urlInput.value.trim();
            if (!baseUrl) {
                alert(`Please enter a URL for ${projectId}`);
                return;
            }

            try {
                const metricsBaseUrl = baseUrl.endsWith('/actuator/metrics/http.server.requests') ? baseUrl : `${baseUrl}/actuator/metrics/http.server.requests`;
                const endpointStats = new Map();

                async function fetchMetric(url) {
                    try {
                        const res = await fetch(url);
                        return await res.json();
                    } catch {
                        return null;
                    }
                }

                function getCount(metric) {
                    return metric?.measurements?.find(m => m.statistic === 'COUNT')?.value ?? 0;
                }

                function getUris(metric) {
                    return metric?.availableTags?.find(t => t.tag === 'uri')?.values ?? [];
                }

                async function collectServerErrors() {
                    const metric = await fetchMetric(`${metricsBaseUrl}?tag=outcome:SERVER_ERROR`);
                    const uris = getUris(metric);
                    for (const uri of uris) {
                        const m = await fetchMetric(
                            `${metricsBaseUrl}?tag=uri:${encodeURI(uri)}&tag=outcome:SERVER_ERROR`
                        );
                        endpointStats.set(uri, {
                            uri,
                            serverErrors: getCount(m),
                            clientErrors: 0,
                            totalCount: 0
                        });
                    }
                }

                async function collectClientErrors() {
                    const metric = await fetchMetric(`${metricsBaseUrl}?tag=outcome:CLIENT_ERROR`);
                    const uris = getUris(metric);
                    for (const uri of uris) {
                        const m = await fetchMetric(
                            `${metricsBaseUrl}?tag=uri:${encodeURI(uri)}&tag=outcome:CLIENT_ERROR`
                        );
                        const existing = endpointStats.get(uri) ?? {
                            uri,
                            serverErrors: 0,
                            clientErrors: 0,
                            totalCount: 0
                        };
                        existing.clientErrors = getCount(m);
                        endpointStats.set(uri, existing);
                    }
                }

                async function collectTotals() {
                    for (const entry of endpointStats.values()) {
                        const m = await fetchMetric(
                            `${metricsBaseUrl}?tag=uri:${encodeURI(entry.uri)}`
                        );
                        entry.totalCount = getCount(m);
                    }
                }

                await collectServerErrors();
                await collectClientErrors();
                await collectTotals();

                printTopByErrorCountHTML(endpointStats, projectId);
                printTopByErrorPercentHTML(endpointStats, projectId);

            } catch (err) {
                const outputDiv = document.getElementById(`endpoint-errors-output-${projectId}`);
                outputDiv.innerHTML = `<pre>Failed to fetch endpoint errors: ${err.message}</pre>`;
            }
        }

        function printTopByErrorCountHTML(endpointStats, projectId) {
            const results = [...endpointStats.values()]
                .map(e => ({
                    ...e,
                    errorCount: e.clientErrors + e.serverErrors,
                    errorPercent: e.totalCount > 0 ? ((e.clientErrors + e.serverErrors) / e.totalCount) * 100 : 0
                }))
                .sort((a, b) => b.errorCount - a.errorCount)
                .slice(0, 10);

            let html = `
            <div class="section">
                <h2>TOP 10 ENDPOINTS BY ERROR COUNT (${projectId})</h2>
                <table>
                    <thead>
                        <tr><th>Errors</th><th>Error %</th><th>Calls</th><th>URI</th></tr>
                    </thead>
                    <tbody>
            `;
            results.forEach(e => {
                html += `<tr><td>${e.errorCount}</td><td>${e.errorPercent.toFixed(1)}%</td><td>${e.totalCount}</td><td>${e.uri}</td></tr>`;
            });
            html += `
                    </tbody>
                </table>
            </div>
            `;

            document.getElementById(`endpoint-errors-output-${projectId}`).innerHTML += html;
        }

        function printTopByErrorPercentHTML(endpointStats, projectId) {
            const results = [...endpointStats.values()]
                .filter(e => e.totalCount > 0)
                .map(e => ({
                    ...e,
                    errorCount: e.clientErrors + e.serverErrors,
                    errorPercent: ((e.clientErrors + e.serverErrors) / e.totalCount) * 100
                }))
                .sort((a, b) => b.errorPercent - a.errorPercent)
                .slice(0, 10);

            let html = `
            <div class="section">
                <h2>TOP 10 ENDPOINTS BY ERROR % (${projectId})</h2>
                <table>
                    <thead>
                        <tr><th>Errors</th><th>Error %</th><th>Calls</th><th>URI</th></tr>
                    </thead>
                    <tbody>
            `;
            results.forEach(e => {
                html += `<tr><td>${e.errorCount}</td><td>${e.errorPercent.toFixed(1)}%</td><td>${e.totalCount}</td><td>${e.uri}</td></tr>`;
            });
            html += `
                    </tbody>
                </table>
            </div>
            `;

            document.getElementById(`endpoint-errors-output-${projectId}`).innerHTML += html;
        }

        // --- General Run All Function ---
        async function runAllScriptsForProject(projectId) {
            await runPrometheusScript(projectId);
            await runSlowEndpointsScript(projectId);
            await runEndpointErrorsScript(projectId);
        }

    </script>
</body>
</html>