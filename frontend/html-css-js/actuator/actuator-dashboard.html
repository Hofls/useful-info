<!--
Replace "someit.com" URLS with real ones
If you try to run it locally and get CORS error, gotta install "CORS Unblock" chrome extension
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Actuator Metrics Dashboard</title>
    <style>
        :root {
            --bg: #fafafa;
            --surface: #ffffff;
            --border: #e0e0e0;
            --text: #333333;
            --text-light: #757575;
            --accent: #000000;
            --accent-light: #f0f0f0;
        }

        body {
            /* Position everything in the center */
            margin: 0 auto;
            max-width: 1200px;
            padding: 0 20px;
            box-sizing: border-box;

            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            font-size: 14px;
            line-height: 1.6;
            font-weight: 400;
        }

        h1 {
            font-weight: 500;
            font-size: 24px;
            margin: 20px 0 20px 0;
            color: var(--accent);
            letter-spacing: -0.5px;
        }

        .header {
            display: flex;
            justify-content: center;
        }

        /* Tab Container */
        .tab-container {
            display: flex;
            margin-bottom: 30px;
            gap: 4px;
        }

        .tab-button {
            padding: 12px 24px;
            cursor: pointer;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            font-size: 14px;
            color: var(--text-light);
            font-weight: 400;
            transition: all 0.15s ease;
            margin-bottom: -1px;
        }

        .tab-button:hover {
            color: var(--text);
        }

        .tab-button.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
            font-weight: 500;
        }

        /* Tab Content */
        .tab-content {
            display: none;
            max-width: 1200px;
        }

        .tab-content.active {
            display: block;
        }

        /* Input and Buttons */
        input[type="text"] {
            width: 97%;
            padding: 12px 16px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
            background: var(--surface);
            font-size: 14px;
            color: var(--text);
            border-radius: 0;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
        }

        button:hover {
            background: var(--accent-light);
            border-color: var(--accent);
        }

        /* Section Styling */
        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            font-weight: 500;
            font-size: 16px;
            margin: 0 0 20px 0;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Table Styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
        }

        th {
            text-align: left;
            padding: 12px 16px;
            font-weight: 500;
            color: var(--text);
            border-bottom: 1px solid var(--border);
            background: #a0beff;
        }

        td {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            color: var(--text);
        }

        tr:last-child td {
            border-bottom: none;
        }

        /* Pre/code styling */
        pre {
            background: var(--surface);
            border: 1px solid var(--border);
            padding: 20px;
            margin: 0;
            font-family: 'SF Mono', Menlo, Monaco, Consolas, monospace;
            font-size: 13px;
            color: var(--text);
            overflow-x: auto;
            white-space: pre-wrap;
        }

        .suspicious-value {
            color:red;
            font-weight:bold;
        }

        .qmark {
            margin: 30px 0px 0px 15px;
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #a0beff;
            color: black;
            font: 16px Arial;
            text-align: center;
            line-height: 24px;
            border-radius: 15px;
            position: relative;
            cursor: help;
        }

        .qmark:hover::after {
            content: "Don't forget to bring number of service replicas down to 1 (all data should come from the same actuator)";
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translate(10px, -50%);
            background: white;
            border: 1px solid black;
            padding: 4px 8px;
            font-size: 13px;
            white-space: nowrap;
            pointer-events: none;
        }

        /* Utility */
        @media (max-width: 768px) {
            body {
                padding: 20px;
            }

            .tab-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .tab-button {
                white-space: nowrap;
            }
        }
    </style>
</head>
<body>
    <div>
        <div class="header">
            <h1>Actuator Metrics Dashboard</h1>
            <span class="qmark">?</span>
        </div>

        <div class="tab-container">
            <button class="tab-button active" onclick="openTab(event, 'ms-actor')">ms-actor</button>
            <button class="tab-button" onclick="openTab(event, 'ms-warehouse')">ms-warehouse</button>
            <button class="tab-button" onclick="openTab(event, 'ms-external')">ms-external</button>
            <button class="tab-button" onclick="openTab(event, 'ms-equipment')">ms-equipment</button>
            <button class="tab-button" onclick="openTab(event, 'ms-user')">ms-user</button>
        </div>

        <div id="ms-actor" class="tab-content active">
            <input type="text" disabled id="url-ms-actor" placeholder="Enter Actuator URL for ms-actor" value="http://someit.com/ms-actor">
            <div id="prometheus-output-ms-actor" class="section"></div>
            <div id="slow-endpoints-output-ms-actor" class="section"></div>
            <div id="endpoint-errors-output-ms-actor" class="section"></div>
        </div>

        <div id="ms-warehouse" class="tab-content">
            <input type="text" disabled id="url-ms-warehouse" placeholder="Enter Actuator URL for ms-warehouse" value="http://someit.com/ms-warehouse">
            <div id="prometheus-output-ms-warehouse" class="section"></div>
            <div id="slow-endpoints-output-ms-warehouse" class="section"></div>
            <div id="endpoint-errors-output-ms-warehouse" class="section"></div>
        </div>

        <div id="ms-external" class="tab-content">
            <input type="text" disabled id="url-ms-external" placeholder="Enter Actuator URL for ms-external" value="http://someit.com/ms-external">
            <div id="prometheus-output-ms-external" class="section"></div>
            <div id="slow-endpoints-output-ms-external" class="section"></div>
            <div id="endpoint-errors-output-ms-external" class="section"></div>
        </div>

        <div id="ms-equipment" class="tab-content">
            <input type="text" disabled id="url-ms-equipment" placeholder="Enter Actuator URL for ms-equipment" value="http://someit.com/ms-equipment">
            <div id="prometheus-output-ms-equipment" class="section"></div>
            <div id="slow-endpoints-output-ms-equipment" class="section"></div>
            <div id="endpoint-errors-output-ms-equipment" class="section"></div>
        </div>

        <div id="ms-user" class="tab-content">
            <input type="text" disabled id="url-ms-user" placeholder="Enter Actuator URL for ms-user" value="http://someit.com/ms-user">
            <div id="prometheus-output-ms-user" class="section"></div>
            <div id="slow-endpoints-output-ms-user" class="section"></div>
            <div id="endpoint-errors-output-ms-user" class="section"></div>
        </div>
    </div>

    <script>
        const initializedTabs = new Set([]);
        const ERROR_STYLE = ' class="suspicious-value"';

        window.addEventListener('load', () => {
            setTimeout(() => {
                if (!initializedTabs.has('ms-actor')) {
                    runAllScriptsForProject('ms-actor');
                    initializedTabs.add('ms-actor');
                }
            }, 100);
        });

        async function runAllScriptsForProject(projectId) {
            runPrometheusScript(projectId);
            runSlowEndpointsScript(projectId);
            runEndpointErrorsScript(projectId);
        }

        function openTab(evt, tabName) {
            var i, tabcontent, tabbuttons;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tabbuttons = document.getElementsByClassName("tab-button");
            for (i = 0; i < tabbuttons.length; i++) {
                tabbuttons[i].className = tabbuttons[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";

            // Run scripts for the tab if it hasn't been initialized yet
            if (!initializedTabs.has(tabName)) {
                runAllScriptsForProject(tabName);
                initializedTabs.add(tabName);
            }
        }

        // --- Prometheus Script Logic ---
        async function runPrometheusScript(projectId) {
            const urlInput = document.getElementById(`url-${projectId}`);
            const url = urlInput.value.trim();
            if (!url) {
                alert(`Please enter a URL for ${projectId}`);
                return;
            }

            try {
                const fullUrl = url.endsWith('/actuator/prometheus') ? url : `${url}/actuator/prometheus`;
                const response = await fetch(fullUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const text = await response.text();
                const data = parsePrometheusMetrics(text);
                printHealthSummaryHTML(data, projectId);
            } catch (err) {
                const outputDiv = document.getElementById(`prometheus-output-${projectId}`);
                outputDiv.innerHTML = `<pre>Failed to fetch or parse metrics: ${err.message}</pre>`;
            }
        }

        function parsePrometheusMetrics(text) {
            const lines = text.split('\n');
            const data = {};
            for (const line of lines) {
                if (!line || line.startsWith('#')) continue;
                const lastSpaceIndex = line.lastIndexOf(' ');
                const keyPart = line.slice(0, lastSpaceIndex).trim();
                const value = Number(line.slice(lastSpaceIndex + 1));
                const num = parseFloat(value);
                if (!keyPart || isNaN(num)) continue;

                const m = keyPart.match(/^([^{]+)(?:{(.*)})?$/);
                if (!m) continue;

                const metric = m[1];
                const labelsStr = m[2] || '';

                if (!labelsStr) {
                    data[metric] = num;
                    continue;
                }

                const name = labelsStr.match(/name="([^"]+)"/)?.[1];
                const state = labelsStr.match(/state="([^"]+)"/)?.[1];
                const id = labelsStr.match(/id="([^"]+)"/)?.[1];
                const level = labelsStr.match(/level="([^"]+)"/)?.[1];

                if (name) {
                    data[`${metric}_${name}`] = num;
                } else if (state) {
                    data[`${metric}_${state}`] = num;
                } else if (id) {
                    const safeId = id.replace(/[^a-zA-Z0-9_]/g, '_');
                    data[`${metric}_${safeId.toLowerCase()}`] = num;
                } else if (level) {
                    data[`${metric}_${level}`] = num;
                } else {
                    data[`${metric}`] = num;
                }
            }
            return data;
        }

        function printHealthSummaryHTML(data, projectId) {
            let html = `
            <div class="section">
                <h2>Spring Boot Quick Health (${projectId})</h2>
                <table>
                    <tr><th>CPU</th><th></th></tr>
            `;

            const cpu = data['process_cpu_usage'] ?? data['system_cpu_usage'];
            const cpuStyle = cpu > 0.85 ? ERROR_STYLE : '';
            html += `<tr><td>CPU usage</td><td${cpuStyle}>${(cpu * 100).toFixed(1)}%</td></tr>`;

            const tenuredUsedStyle = data['jvm_memory_used_bytes_tenured_gen'] / data['jvm_memory_max_bytes_tenured_gen'] > 0.8 ? ERROR_STYLE : '';
            const edenUsedStyle = data['jvm_memory_used_bytes_eden_space'] / data['jvm_memory_max_bytes_eden_space'] > 0.9 ? ERROR_STYLE : '';
            const survivorUsedStyle = data['jvm_memory_used_bytes_survivor_space'] / data['jvm_memory_max_bytes_survivor_space'] > 0.9 ? ERROR_STYLE : '';
            const metaspaceUsedStyle = data['jvm_memory_used_bytes_metaspace'] > 512 * 1024 * 1024 ? ERROR_STYLE : '';
            const ccsUsedStyle = data['jvm_memory_used_bytes_compressed_class_space'] > (data['jvm_memory_max_bytes_compressed_class_space'] * 0.75) ? ERROR_STYLE : '';

            html += `
                    <tr><th>JVM Memory — USED</th><th></th></tr>
                    <tr><td>Heap Tenured used<br><small>(old generation – long-lived objects)</small></td><td${tenuredUsedStyle}>${(data['jvm_memory_used_bytes_tenured_gen'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap Eden used<br><small>(young generation – where new objects are allocated)</small></td><td${edenUsedStyle}>${(data['jvm_memory_used_bytes_eden_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap Survivor used<br><small>(young gen – objects that survived GC cycles)</small></td><td${survivorUsedStyle}>${(data['jvm_memory_used_bytes_survivor_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>MetaSpace used<br><small>(class metadata, method bytecode, interned strings...)</small></td><td${metaspaceUsedStyle}>${(data['jvm_memory_used_bytes_metaspace'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Compressed Class Space used<br><small>(compressed pointers – class metadata subset, 32-bit JVMs)</small></td><td${ccsUsedStyle}>${(data['jvm_memory_used_bytes_compressed_class_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
            `;

            const metaSpaceMax = data['jvm_memory_max_bytes_metaspace'] === -1 ? 'Unlimited' : (data['jvm_memory_max_bytes_metaspace'] / 1024 / 1024).toFixed(1) + ' MB';
            html += `
                    <tr><th>JVM Memory — MAX</th><th></th></tr>
                    <tr><td>Heap Tenured max<br><small>(maximum size old generation can grow to)</small></td><td>${(data['jvm_memory_max_bytes_tenured_gen'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap Eden max<br><small>(max size of Eden – usually -Xmn / young gen config)</small></td><td>${(data['jvm_memory_max_bytes_eden_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap Survivor max<br><small>(max size of each survivor space)</small></td><td>${(data['jvm_memory_max_bytes_survivor_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>MetaSpace max<br><small>(-XX:MaxMetaspaceSize limit, often unlimited)</small></td><td>${metaSpaceMax}</td></tr>
                    <tr><td>Compressed Class Space max<br><small>(usually fixed ~1 GB on 64-bit JVMs)</small></td><td>${(data['jvm_memory_max_bytes_compressed_class_space'] / 1024 / 1024).toFixed(1)} MB</td></tr>
            `;

            const heapAfterGcStyle = data['jvm_memory_usage_after_gc_percent'] > 0.75 ? ERROR_STYLE : '';
            const classesLoadedStyle = data['jvm_classes_loaded_classes'] > 75000 ? ERROR_STYLE : '';

            html += `
                    <tr><th>Memory</th><th></th></tr>
                    <tr><td>Live heap post-GC<br><small>(old generation size after last major GC)</small></td><td>${(data['jvm_gc_live_data_size_bytes'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Heap used after GC<br><small>(% of max heap used right after GC)</small></td><td${heapAfterGcStyle}>${(data['jvm_memory_usage_after_gc_percent'] * 100).toFixed(1)}%</td></tr>
                    <tr><td>Promoted to old-gen<br><small>(total bytes promoted from young→old since start)</small></td><td>${(data['jvm_gc_memory_promoted_bytes_total'] / 1024 / 1024).toFixed(1)} MB</td></tr>
                    <tr><td>Classes loaded<br><small>(current number of loaded classes)</small></td><td${classesLoadedStyle}>${data['jvm_classes_loaded_classes']}</td></tr>
            `;

            const runnableThreadsStyle = data['jvm_threads_states_threads_runnable'] < 1 ? ERROR_STYLE : '';
            const blockedThreadsStyle = data['jvm_threads_states_threads_blocked'] > 0 ? ERROR_STYLE : '';

            html += `
                    <tr><th>Threads</th><th></th></tr>
                    <tr><td>Peak threads<br><small>(highest number of live threads ever)</small></td><td>${data['jvm_threads_peak_threads'] | 0}</td></tr>
                    <tr><td>Runnable threads<br><small>(threads ready to run or running)</small></td><td${runnableThreadsStyle}>${data['jvm_threads_states_threads_runnable'] | 0}</td></tr>
                    <tr><td>Waiting threads<br><small>(threads in WAITING state – Object.wait())</small></td><td>${data['jvm_threads_states_threads_waiting'] | 0}</td></tr>
                    <tr><td>Timed waiting threads<br><small>(threads in TIMED_WAITING – sleep, wait(timeout), parkNanos...)</small></td><td>${data['jvm_threads_states_threads_timed'] | 0}</td></tr>
                    <tr><td>Blocked threads<br><small>(threads waiting for monitor – synchronized block)</small></td><td${blockedThreadsStyle}>${data['jvm_threads_states_threads_blocked'] | 0}</td></tr>
                    <tr><td>Daemon threads<br><small>(background threads – don't prevent JVM exit)</small></td><td>${data['jvm_threads_daemon_threads'] | 0}</td></tr>
            `;

            const uptimeMinutes = Math.floor((Date.now()/1000 - data['process_start_time_seconds']) / 60);
            const openFilesStyle = data['process_files_open_files'] > 400 ? ERROR_STYLE : '';
            const startupStyle = data['application_started_time_seconds'] > 180 ? ERROR_STYLE : '';
            const readyStyle = data['application_ready_time_seconds'] > 180 ? ERROR_STYLE : '';
            const errorLogsStyle = (data['logback_events_total_error'] / uptimeMinutes) > 1 ? ERROR_STYLE : '';
            const diskFreeGb = data['disk_free_bytes'] / 1024 / 1024 / 1024;
            const diskFreeStyle = diskFreeGb < 6 ? ERROR_STYLE : '';

            html += `
                    <tr><th>Other</th><th></th></tr>
                    <tr><td>Uptime<br><small>(how long the JVM process has been running)</small></td><td>${uptimeMinutes} min</td></tr>
                    <tr><td>Open files<br><small>(number of open file descriptors)</small></td><td${openFilesStyle}>${data['process_files_open_files']}</td></tr>
                    <tr><td>Startup time<br><small>(time from process start to Spring Boot started event)</small></td><td${startupStyle}>${data['application_started_time_seconds']} s</td></tr>
                    <tr><td>Ready time<br><small>(time from start to application fully ready – readiness probe)</small></td><td${readyStyle}>${data['application_ready_time_seconds']} s</td></tr>
                    <tr><td>Errors logged<br><small>(total ERROR level log events via Logback)</small></td><td${errorLogsStyle}>${data['logback_events_total_error']}</td></tr>
                    <tr><td>Disk free<br><small>(free space on the filesystem where JVM runs)</small></td><td${diskFreeStyle}>${diskFreeGb.toFixed(1)} GB</td></tr>
            `;

            const tasksQueued = data['executor_queued_tasks_threadPoolTaskScheduler'] ? data['executor_queued_tasks_threadPoolTaskScheduler'] : data['executor_queued_tasks_taskScheduler'];
            const tasksCompleted = data['executor_completed_tasks_total_threadPoolTaskScheduler'] ? data['executor_completed_tasks_total_threadPoolTaskScheduler'] : data['executor_completed_tasks_total_taskScheduler'];
            const executorThreads = data['executor_pool_size_threads_threadPoolTaskScheduler'] ? data['executor_pool_size_threads_threadPoolTaskScheduler'] : data['executor_pool_size_threads_taskScheduler'];
            const executorThreadsStyle = executorThreads < 1 ? ERROR_STYLE : '';

            html += `
                    <tr><th>Executor</th><th></th></tr>
                    <tr><td>Tasks queued<br><small>(currently waiting in the task queue)</small></td><td>${tasksQueued}</td></tr>
                    <tr><td>Tasks completed<br><small>(total tasks finished since start)</small></td><td>${tasksCompleted}</td></tr>
                    <tr><td>Executor threads<br><small>(current number of threads in pool)</small></td><td${executorThreadsStyle}>${executorThreads}</td></tr>
            `;

            const dbMinMaxStyle = (data['jdbc_connections_min_dataSource'] < 1 || data['jdbc_connections_max_dataSource'] < 1) ? ERROR_STYLE : '';
            const dbActiveStyle = data['hikaricp_connections_active'] > data['jdbc_connections_max_dataSource'] * 0.7 ? ERROR_STYLE : '';
            const dbPoolSizeStyle = data['hikaricp_connections'] < 1 ? ERROR_STYLE : '';
            const dbMaxUsageStyle = data['hikaricp_connections_usage_seconds_max'] > 2 ? ERROR_STYLE : '';
            const dbPendingStyle = data['hikaricp_connections_pending'] > 0 ? ERROR_STYLE : '';
            const dbAcquireStyle = data['hikaricp_connections_acquire_seconds_max'] > 3 ? ERROR_STYLE : '';
            const dbTimeoutStyle = data['hikaricp_connections_timeout_total'] > 0 ? ERROR_STYLE : '';

            html += `
                    <tr><th>Database</th><th></th></tr>
                    <tr><td>DB connections min–max<br><small>(configured min/max pool size)</small></td><td${dbMinMaxStyle}>${data['jdbc_connections_min_dataSource'] | 0}–${data['jdbc_connections_max_dataSource'] | 0}</td></tr>
                    <tr><td>DB connections active<br><small>(currently in use by application)</small></td><td${dbActiveStyle}>${data['hikaricp_connections_active']}</td></tr>
                    <tr><td>DB pool size<br><small>(total connections in Hikari pool right now)</small></td><td${dbPoolSizeStyle}>${data['hikaricp_connections']}</td></tr>
                    <tr><td>DB max usage<br><small>(longest time any connection was borrowed)</small></td><td${dbMaxUsageStyle}>${(data['hikaricp_connections_usage_seconds_max'] * 1000).toFixed(1)} ms</td></tr>
                    <tr><td>DB connections pending<br><small>(threads waiting for a connection)</small></td><td${dbPendingStyle}>${data['hikaricp_connections_pending']}</td></tr>
                    <tr><td>DB connections acquire max<br><small>(worst-case time to get connection from pool)</small></td><td${dbAcquireStyle}>${data['hikaricp_connections_acquire_seconds_max']} s</td></tr>
                    <tr><td>DB connections timeout<br><small>(total times getConnection() timed out)</small></td><td${dbTimeoutStyle}>${data['hikaricp_connections_timeout_total']}</td></tr>
                </table>
            `;

            document.getElementById(`prometheus-output-${projectId}`).innerHTML = html;
        }

        // --- Slow Endpoints Script Logic ---
        async function runSlowEndpointsScript(projectId) {
            const urlInput = document.getElementById(`url-${projectId}`);
            const baseUrl = urlInput.value.trim();
            if (!baseUrl) {
                alert(`Please enter a URL for ${projectId}`);
                return;
            }

            try {
                const metricsBaseUrl = baseUrl.endsWith('/actuator/metrics/http.server.requests') ? baseUrl : `${baseUrl}/actuator/metrics/http.server.requests`;
                const endpointData = [];

                async function getAverageTime(endpointUrl) {
                    try {
                        const response = await fetch(endpointUrl);
                        const data = await response.json();
                        const totalTime = data.measurements.find((metric) => metric.statistic === 'TOTAL_TIME').value;
                        const count = data.measurements.find((metric) => metric.statistic === 'COUNT').value;
                        const averageTime = totalTime / count;
                        endpointData.push({ endpointUrl, averageTime });
                    } catch (e) {
                        // Silently ignore errors as per original script
                    }
                }

                async function getEndpointPaths() {
                    const response = await fetch(metricsBaseUrl);
                    const data = await response.json();
                    return data.availableTags.find(tag => tag.tag === 'uri').values;
                }

                const endpointPaths = await getEndpointPaths();
                for (const endpointPath of endpointPaths) {
                    const encodedPath = encodeURI(endpointPath);
                    const endpointMetricsUrl = `${metricsBaseUrl}?tag=uri:${encodedPath}`;
                    await getAverageTime(endpointMetricsUrl);
                }

                printSlowEndpointsHTML(endpointData, projectId);

            } catch (err) {
                const outputDiv = document.getElementById(`slow-endpoints-output-${projectId}`);
                outputDiv.innerHTML = `<pre>Failed to fetch slow endpoints: ${err.message}</pre>`;
            }
        }

        function printSlowEndpointsHTML(endpointData, projectId) {
            endpointData.sort((a, b) => b.averageTime - a.averageTime);
            const top15 = endpointData.slice(0, 15);

            let html = `
            <div class="section">
                <h2>TOP 15 SLOWEST ENDPOINTS (${projectId})</h2>
                <table>
                    <thead>
                        <tr><th>Average Time (seconds)</th><th>Endpoint</th></tr>
                    </thead>
                    <tbody>
            `;

            top15.forEach(item => {
                const time = item.averageTime;
                const isSuspicious = time >= 2;

                html += `
                    <tr>
                        <td${isSuspicious ? ERROR_STYLE : ''}>${time.toFixed(2)}</td>
                        <td>${item.endpointUrl}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            </div>
            `;

            document.getElementById(`slow-endpoints-output-${projectId}`).innerHTML = html;
        }


        // --- Endpoint Errors Script Logic ---
        async function runEndpointErrorsScript(projectId) {
            const urlInput = document.getElementById(`url-${projectId}`);
            const baseUrl = urlInput.value.trim();
            if (!baseUrl) {
                alert(`Please enter a URL for ${projectId}`);
                return;
            }

            try {
                const metricsBaseUrl = baseUrl.endsWith('/actuator/metrics/http.server.requests') ? baseUrl : `${baseUrl}/actuator/metrics/http.server.requests`;
                const endpointStats = new Map();

                async function fetchMetric(url) {
                    try {
                        const res = await fetch(url);
                        return await res.json();
                    } catch {
                        return null;
                    }
                }

                function getCount(metric) {
                    return metric?.measurements?.find(m => m.statistic === 'COUNT')?.value ?? 0;
                }

                function getUris(metric) {
                    return metric?.availableTags?.find(t => t.tag === 'uri')?.values ?? [];
                }

                async function collectServerErrors() {
                    const metric = await fetchMetric(`${metricsBaseUrl}?tag=outcome:SERVER_ERROR`);
                    const uris = getUris(metric);
                    for (const uri of uris) {
                        const m = await fetchMetric(
                            `${metricsBaseUrl}?tag=uri:${encodeURI(uri)}&tag=outcome:SERVER_ERROR`
                        );
                        endpointStats.set(uri, {
                            uri,
                            serverErrors: getCount(m),
                            clientErrors: 0,
                            totalCount: 0
                        });
                    }
                }

                async function collectClientErrors() {
                    const metric = await fetchMetric(`${metricsBaseUrl}?tag=outcome:CLIENT_ERROR`);
                    const uris = getUris(metric);
                    for (const uri of uris) {
                        const m = await fetchMetric(
                            `${metricsBaseUrl}?tag=uri:${encodeURI(uri)}&tag=outcome:CLIENT_ERROR`
                        );
                        const existing = endpointStats.get(uri) ?? {
                            uri,
                            serverErrors: 0,
                            clientErrors: 0,
                            totalCount: 0
                        };
                        existing.clientErrors = getCount(m);
                        endpointStats.set(uri, existing);
                    }
                }

                async function collectTotals() {
                    for (const entry of endpointStats.values()) {
                        const m = await fetchMetric(
                            `${metricsBaseUrl}?tag=uri:${encodeURI(entry.uri)}`
                        );
                        entry.totalCount = getCount(m);
                    }
                }

                await collectServerErrors();
                await collectClientErrors();
                await collectTotals();

                printTopByErrorPercentHTML(endpointStats, projectId);
                printTopByErrorCountHTML(endpointStats, projectId);

            } catch (err) {
                const outputDiv = document.getElementById(`endpoint-errors-output-${projectId}`);
                outputDiv.innerHTML = `<pre>Failed to fetch endpoint errors: ${err.message}</pre>`;
            }
        }

        function printTopByErrorCountHTML(endpointStats, projectId) {
            const results = [...endpointStats.values()]
                .map(e => ({
                    ...e,
                    errorCount: e.clientErrors + e.serverErrors,
                    errorPercent: e.totalCount > 0 ? ((e.clientErrors + e.serverErrors) / e.totalCount) * 100 : 0
                }))
                .sort((a, b) => b.errorCount - a.errorCount)
                .slice(0, 10);

            let html = `
            <div class="section">
                <h2>TOP 10 ENDPOINTS BY ERROR COUNT (${projectId})</h2>
                <table>
                    <thead>
                        <tr><th>Errors</th><th>Error %</th><th>Calls</th><th>URI</th></tr>
                    </thead>
                    <tbody>
            `;
            results.forEach(e => {
                const isBad = e.errorPercent > 15;
                html += `
                    <tr>
                        <td>${e.errorCount}</td>
                        <td${isBad ? ERROR_STYLE : ''}>${e.errorPercent.toFixed(1)}%</td>
                        <td>${e.totalCount}</td>
                        <td>${e.uri}</td>
                    </tr>
                `;
            });
            html += `
                    </tbody>
                </table>
            </div>
            `;

            document.getElementById(`endpoint-errors-output-${projectId}`).innerHTML += html;
        }

        function printTopByErrorPercentHTML(endpointStats, projectId) {
            const results = [...endpointStats.values()]
                .filter(e => e.totalCount > 0)
                .map(e => ({
                    ...e,
                    errorCount: e.clientErrors + e.serverErrors,
                    errorPercent: ((e.clientErrors + e.serverErrors) / e.totalCount) * 100
                }))
                .sort((a, b) => b.errorPercent - a.errorPercent)
                .slice(0, 10);

            let html = `
            <div class="section">
                <h2>TOP 10 ENDPOINTS BY ERROR % (${projectId})</h2>
                <table>
                    <thead>
                        <tr><th>Errors</th><th>Error %</th><th>Calls</th><th>URI</th></tr>
                    </thead>
                    <tbody>
            `;

            results.forEach(e => {
                const isBad = e.errorPercent > 15;
                html += `
                    <tr>
                        <td>${e.errorCount}</td>
                        <td${isBad ? ERROR_STYLE : ''}>${e.errorPercent.toFixed(1)}%</td>
                        <td>${e.totalCount}</td>
                        <td>${e.uri}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            </div>
            `;

            document.getElementById(`endpoint-errors-output-${projectId}`).innerHTML += html;
        }

    </script>
</body>
</html>